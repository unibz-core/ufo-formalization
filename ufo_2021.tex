
%%%%%%%%%%%%%%%%%%%%%%%% Taxonomy %%%%%%%%%%%%%%%%%%%%%%%%

% Thing

fof(ax_thing_taxonomy, axiom, (
  ![X]: ((type(X) | individual(X)) <=> (thing(X)))
)).

fof(ax_thing_partition, axiom, (
  ~?[X]: (type(X) & individual(X))
)).

% Individual

fof(ax_individual_taxonomy, axiom, (
  ![X]: ((concreteIndividual(X) | abstractIndividual(X)) <=> (individual(X)))
)).

fof(ax_individual_partition, axiom, (
  ~?[X]: (concreteIndividual(X) & abstractIndividual(X))
)).

% Concrete Individual

fof(ax_concreteIndividual_taxonomy, axiom, (
  ![X]: ((endurant(X) | perdurant(X)) <=> (concreteIndividual(X)))
)).

fof(ax_concreteIndividual_partition, axiom, (
  ~?[X]: (endurant(X) & perdurant(X))
)).

% Type

fof(ax_type_taxonomy, axiom, (
  ![X]: ((endurantType(X) | perdurantType(X)) <=> (type(X)))
)).

fof(ax_type_partition, axiom, (
  ~?[X]: (endurantType(X) & perdurantType(X))
)).

% Thing partial taxonomy instances
% (tested rule out trivial models)

% fof(ax_thing_instances, axiom, (
%   type(type1) & individual(individual1) & concreteIndividual(concreteIndividual1) & abstractIndividual(abstractIndividual1) & endurant(endurant1) & perdurant(perdurant1) & endurantType(endurantType1) & perdurantType(perdurantType1)
% )).

% Abstract Individual

fof(ax_abstractIndividual_taxonomy_quale, axiom, (
  ![X]: (quale(X) => (abstractIndividual(X)))
)).

fof(ax_abstractIndividual_taxonomy_set, axiom, (
  ![X]: (set(X) => (abstractIndividual(X)))
)).

% Set

fof(ax_set_taxonomy_qualityStructure, axiom, (
  ![X]: (qualityStructure(X) => (set(X)))
)).

% Quality Structure

fof(ax_qualityStructure_taxonomy, axiom, (
  ![X]: ((qualityDimension(X) | qualitySpace(X)) <=> (qualityStructure(X)))
)).

fof(ax_qualityStructure_partition, axiom, (
  ~?[X]: (qualityDimension(X) & qualitySpace(X))
)).

% TODO: review the definition of "world" as a subtype of "qualityStructure"

fof(ax_qualityStructure_taxonomy_world, axiom, (
  ![X]: (world(X) => (qualityStructure(X)))
)).

% Abstract Individual partial taxonomy instances
% (tested rule out trivial models)

% fof(ax_abstractIndividual_instances, axiom, (
%   set(set1) & quale(quale1) & qualityStructure(qualityStructure1) & qualityDimension(qualityDimension1) & qualitySpace(qualitySpace1) & world(world1)
% )).

% Endurant

fof(ax_endurant_taxonomy, axiom, (
  ![X]: ((substantial(X) | moment(X)) <=> (endurant(X)))
)).

fof(ax_endurant_partition, axiom, (
  ~?[X]: (substantial(X) & moment(X))
)).

% Substantial

fof(ax_substantial_taxonomy, axiom, (
  ![X]: ((object(X) | collective(X) | quantity(X)) <=> (substantial(X)))
)).

fof(ax_substantial_partition, axiom, (
  ~?[X]: ((object(X) & collective(X)) | (object(X) & quantity(X)) | (collective(X) & quantity(X)))
)).

% Moment

fof(ax_moment_taxonomy, axiom, (
  ![X]: ((intrinsicMoment(X) | relator(X)) <=> (moment(X)))
)).

fof(ax_moment_partition, axiom, (
  ~?[X]: (intrinsicMoment(X) & relator(X))
)).

% Intrinsic Moment

fof(ax_intrinsicMoment_taxonomy, axiom, (
  ![X]: ((quality(X) | mode(X)) <=> (intrinsicMoment(X)))
)).

fof(ax_intrinsicMoment_partition, axiom, (
  ~?[X]: (quality(X) & mode(X))
)).

% Mode

fof(ax_mode_taxonomy_externallyDependentMode, axiom, (
  ![X]: (externallyDependentMode(X) => (mode(X)))
)).

% Externally Dependent Mode

fof(ax_externallyDependentMode_taxonomy_quaIndividual, axiom, (
  ![X]: (quaIndividual(X) => (externallyDependentMode(X)))
)).

% Endurant partial taxonomy instances
% (tested rule out trivial models)

% fof(ax_endurant_instances, axiom, (
%   substantial(substantial1) & moment(moment1) & object(object1) & collective(collective1) & quantity(quantity1) & intrinsicMoment(intrinsicMoment1) & relator(relator1) & quality(quality1) & mode(mode1) & disposition(disposition1) & externallyDependentMode(externallyDependentMode1) & quaIndividual(quaIndividual1)
% )).

% Endurant Type (by ontological nature)

fof(ax_endurantType_taxonomy_nature, axiom, (
  ![X]: ((substantialType(X) | momentType(X)) <=> (endurantType(X)))
)).

fof(ax_endurantType_partition_nature, axiom, (
  ~?[X]: (substantialType(X) & momentType(X))
)).

% Substantial Type

fof(ax_substantialType_taxonomy, axiom, (
  ![X]: ((objectType(X) | collectiveType(X) | quantityType(X)) <=> (substantialType(X)))
)).

fof(ax_substantialType_partition, axiom, (
  ~?[X]: ((objectType(X) & collectiveType(X)) | (objectType(X) & quantityType(X)) | (collectiveType(X) & quantityType(X)))
)).

% Moment Type

fof(ax_momentType_taxonomy, axiom, (
  ![X]: ((intrinsicMomentType(X) | relatorType(X)) <=> (momentType(X)))
)).

fof(ax_momentType_partition, axiom, (
  ~?[X]: (intrinsicMomentType(X) & relatorType(X))
)).

% Intrinsic Moment Type

fof(ax_intrinsicMomentType_taxonomy, axiom, (
  ![X]: ((qualityType(X) | modeType(X)) <=> (intrinsicMomentType(X)))
)).

fof(ax_intrinsicMomentType_partition, axiom, (
  ~?[X]: (qualityType(X) & modeType(X))
)).

% Endurant Type (by ontological nature) partial taxonomy instances
% (tested rule out trivial models)

% fof(ax_endurantType_instances_natures, axiom, (
%   substantialType(substantialType1) & momentType(momentType1) & objectType(objectType1) & collectiveType(collectiveType1) & quantityType(quantityType1) & intrinsicMomentType(intrinsicMomentType1) & relatorType(relatorType1) & qualityType(qualityType1) & modeType(modeType1) & externallyDependentModeType(externallyDependentModeType1) & quaIndividualType(quaIndividualType1)
% )).

% Endurant Type (by modal properties of types)

fof(ax_endurantType_taxonomy_properties, axiom, (
  ![X]: ((sortal(X) | nonSortal(X)) <=> (endurantType(X)))
)).

fof(ax_endurantType_partition_properties, axiom, (
  ~?[X]: (sortal(X) & nonSortal(X))
)).

% Sortal

fof(ax_sortal_taxonomy, axiom, (
  ![X]: ((rigidSortal(X) | antiRigidSortal(X)) <=> (sortal(X)))
)).

fof(ax_sortal_partition, axiom, (
  ~?[X]: (rigidSortal(X) & antiRigidSortal(X))
)).

% Rigid Sortal

fof(ax_rigidSortal_taxonomy, axiom, (
  ![X]: ((kind(X) | subkind(X)) <=> (rigidSortal(X)))
)).

fof(ax_rigidSortal_partition, axiom, (
  ~?[X]: (kind(X) & subkind(X))
)).

% Anti-Rigid Sortal

fof(ax_antiRigidSortal_taxonomy, axiom, (
  ![X]: ((phase(X) | role(X)) <=> (antiRigidSortal(X)))
)).

fof(ax_antiRigidSortal_partition, axiom, (
  ~?[X]: (phase(X) & role(X))
)).

% Non-Sortal

fof(ax_nonSortal_taxonomy, axiom, (
  ![X]: ((rigidNonSortal(X) | semiRigidNonSortal(X) | antiRigidNonSortal(X)) <=> (nonSortal(X)))
)).

fof(ax_nonSortal_partition, axiom, (
  ~?[X]: ((rigidNonSortal(X) & semiRigidNonSortal(X)) | (rigidNonSortal(X) & antiRigidNonSortal(X)) | (semiRigidNonSortal(X) & antiRigidNonSortal(X)))
)).

% Category

fof(ax_rigidNonSortal_taxonomy, axiom, (
  ![X]: (rigidNonSortal(X) <=> (category(X)))
)).

% Mixin

fof(ax_semiRigidNonSortal_taxonomy, axiom, (
  ![X]: (semiRigidNonSortal(X) <=> (mixin(X)))
)).

% Anti-Rigid Non-Sortal

fof(ax_antiRigidNonSortal_taxonomy, axiom, (
  ![X]: ((phaseMixin(X) | roleMixin(X)) <=> (antiRigidNonSortal(X)))
)).

fof(ax_antiRigidNonSortal_partition, axiom, (
  ~?[X]: (phaseMixin(X) & roleMixin(X))
)).

% Endurant Type (by modal properties of types) partial taxonomy instances
% (tested rule out trivial models)

% fof(ax_endurantType_instances_properties, axiom, (
%   sortal(sortal1) & nonSortal(nonSortal1) & rigidSortal(rigidSortal1) & antiRigidSortal(antiRigidSortal1) & kind(kind1) & subkind(subkind1) & phase(phase1) & role(role1) & category(category1) & mixin(mixin1) & antiRigidNonSortal(antiRigidNonSortal1) & phaseMixin(phaseMixin1) & roleMixin(roleMixin1)
% )).

%%%%%%%%%%% Instance of, Types, and Individuals %%%%%%%%%%

fof(ax_dIof, axiom, (
  ![X,Y,W]: (iof(X,Y,W) => (type(Y) & world(W)))
)).

fof(ax_dType_a1, axiom, (
  ![X]: (type(X) <=> (?[Y,W]: iof(Y,X,W)))
)).

fof(ax_dIndividual_a2, axiom, (
  ![X]: (individual(X) <=> (~?[Y,W]: iof(Y,X,W)))
)).

% TODO: confirm whether we are including second-order types in this formalization

fof(ax_multiLevel_a3, axiom, (
  ![X,Y,W]: (iof(X,Y,W) => (type(X) | individual(X)))
)).

fof(ax_twoLevelConstrained_a4, axiom, (
  ~?[X,Y,Z,W]: (type(X) & iof(X,Y,W) & iof(Y,Z,W))
)).

% fof(ax_iofInUse, axiom, (
%   type(t2) & individual(i2) & world(w2) & iof(i2,t2,w2)
% )).

% Ax |= "th_everythingIsAThing_t1"; conjecture commented for convenience

% fof(th_everythingIsAThing_t1, conjecture, (
%   ![X]: (type(X) | individual(X))
% )).

% Ax |= "th_thingPartition_t2"; conjecture commented for convenience

% fof(th_thingPartition_t2, conjecture, (
%   ~?[X]: (type(X) & individual(X))
% )).

%%%%%%%% Specialization and Proper Specialization %%%%%%%%

fof(ax_dSpecializes, axiom, (
  ![X,Y]: (specializes(X,Y) => (type(X) & type(Y)))
)).

fof(ax_specialization_a5, axiom, (
  ![T1,T2]: (specializes(T1,T2) <=> (
    type(T1) & type(T2) & ![W]: (world(W) => ![E]: (iof(E,T1,W) => iof(E,T2,W)))
  ))
)).

fof(ax_properSpecializes_d1, axiom, (
  ![X,Y]: (properSpecializes(X,Y) <=> (specializes(X,Y) & ~specializes(Y,X)))
)).

% fof(ax_specializesInUse, axiom, (
%   type(t3_1) & type(t3_2) & specializes(t3_1,t3_2) & properSpecializes(t3_1,t3_2) & specializes(t3_1,t3_1)
% )).

% Ax |= "th_cyclicSpecializations_t3"; conjecture commented for convenience

% fof(th_cyclicSpecializations_t3, conjecture, (
%   ![X,Y]: (specializes(X,Y) => (specializes(X,X) & specializes(Y,Y)))
% )).

% Ax |= "th_transitiveSpecializations_t4"; conjecture commented for convenience

% fof(th_transitiveSpecializations_t4, conjecture, (
%   ![X,Y,Z]: ((specializes(X,Y) & specializes(Y,Z)) => (specializes(X,Z)))
% )).

fof(ax_sharedSpecializations_a6, axiom, (
  ![T1,T2]: (?[X,W]: ((iof(X,T1,W) & iof(X,T2,W) & ~specializes(T1,T2) & ~specializes(T2,T1)) => (
      (?[T3]: (specializes(T1,T3) & specializes(T2,T3) & iof(X,T3,W)))|
      (?[T3]: (specializes(T3,T1) & specializes(T3,T2) & iof(X,T3,W)))
  )))
)).

%%%%%%%%%%%%%%%%% Sortality and Rigidity %%%%%%%%%%%%%%%%%

% TODO: I don't find we need to attach the "rigid(T)" predicate to the "endurant(T)" predicate like the paper does, so let's review this idea.
% TODO: verify whether it is a problem not to introduce predicates "world(W1) &" and "world(W2) &" before each instantiation

fof(ax_dRigid_a18, axiom, (
  ![T]: (rigid(T) <=> (endurantType(T) & (
    ![X]: ((![W1]: (world(W1) & iof(X,T,W1))) => (![W2]: (world(W2) => iof(X,T,W2)))
  ))))
)).

fof(ax_dAntiRigid_a19, axiom, (
  ![T]: (antiRigid(T) <=> (endurantType(T) & (
    ![X]: ((![W1]: (world(W1) & iof(X,T,W1))) => (?[W2]: (world(W2) & ~iof(X,T,W2)))
  ))))
)).

fof(ax_dSemiRigid_a20, axiom, (
  ![T]: (semiRigid(T) <=> (endurantType(T) & ~rigid(T) & ~antiRigid(T)))
)).

% Ax |= "th_thEndurantTypeHaveRigidity_t5"; conjecture commented for convenience

% fof(th_thEndurantTypeHaveRigidity_t5, conjecture, (
%   ![T]: (endurantType(T) <=> (rigid(T) | semiRigid(T) | antiRigid(T)))
% )).

% Ax |= "th_pairwiseDisjointRigidities_t6"; conjecture commented for convenience

% fof(th_pairwiseDisjointRigidities_t6, conjecture, (
%   ~![T]: ((rigid(T) & semiRigid(T)) | (semiRigid(T) & antiRigid(T)) | (rigid(T) & antiRigid(T)))
% )).

% Ax |= "th_rigidAntiRigidSpecializationConstraint_t7"; conjecture commented for convenience

% fof(th_rigidAntiRigidSpecializationConstraint_t7, conjecture, (
%   ~![T1,T2]: (rigid(T1) & antiRigid(T2) & specializes(T1,T2))
% )).

% Ax |= "th_semiRigidAntiRigidSpecializationConstraint_t8"; conjecture commented for convenience

% fof(th_semiRigidAntiRigidSpecializationConstraint_t8, conjecture, (
%   ~![T1,T2]: (semiRigid(T1) & antiRigid(T2) & specializes(T1,T2))
% )).

fof(ax_endurantsKind_a21, axiom, (
  ![E]: (endurant(E) => (
    ?[U]: (kind(U) & (![W]: (world(W) & iof(E,U,W))))
  ))
)).

fof(ax_uniqueKind_a22, axiom, (
  ![E,U,W]: ((world(W) & kind(U) & iof(E,U,W)) => (
    ~?[U2,W2]: (kind(U2) & iof(E,U2,W2) & ~(U = U2))
  ))
)).

% Changing "ax_dSortal_a23" from the form it was defined in the paper to "sortals are endurant types that specialize some ultimate sortal" seem to express the same concept while speeding up the execution of SPASS considerably

% fof(ax_dSortal_a23, axiom, (
%   ![S]: (sortal(S) <=> (endurantType(S) & (?[U]: (kind(U) & (![E,W]: (iof(E,S,W) => iof(E,U,W)))))))
% )).

fof(ax_dSortal_a23, axiom, (
  ![S]: ((sortal(S)) <=> (endurantType(S) & (?[U]: (kind(U) & specializes(S,U)))))
)).

% If we have the taxonomy's axiomatization, then a24 becomes a theorem
% Ax |= "th_nonSortalsAreEndurantsThatAreNotSortals_a24"; conjecture commented for convenience

% fof(th_nonSortalsAreEndurantsThatAreNotSortals_a24, conjecture, (
%   ![NS]: ((nonSortal(NS)) <=> (endurantType(NS) & ~sortal(NS)))
% )).

% Ax |= "th_kindsAreRigid_t9"; conjecture commented for convenience

% fof(th_kindsAreRigid_t9, conjecture, (
%   ![U]: ((kind(U)) => (rigid(U)))
% )).

% Ax |= "th_kindsHaveDisjointExtensions_t10"; conjecture commented for convenience

% fof(th_kindsHaveDisjointExtensions_t10, conjecture, (
%   ![K1,K2]: ((kind(K1) & kind(K2) & ~(K1=K2)) => (
%     ~?[X,W1,W2]: (world(W1) & world(W2) & iof(X,K1,W1) & iof(X,K2,W2)))
%   )
% )).

% Ax |= "th_kindsHaveDisjointTaxonomies_t11"; conjecture commented for convenience

% fof(th_kindsHaveDisjointTaxonomies_t11, conjecture, (
%   ![K1,K2]: ((kind(K1) & kind(K2) & ~(K1=K2)) => (
%     ~?[T]: (specializes(T,K1) & specializes(T,K2)))
%   )
% )).

% Ax |= "th_kindsAreSortal_t12"; conjecture commented for convenience

% fof(th_kindsAreSortal_t12, conjecture, (
%   ![K]: ((kind(K)) => (sortal(K)))
% )).

% Ax |= "th_sortalSpecializeKinds_t13"; conjecture commented for convenience

% fof(th_sortalSpecializeKinds_t13, conjecture, (
%   ![S]: ((sortal(S)) => (?[K]: (kind(K) & specializes(S,K))))
% )).

% Ax |= "th_sortalsSpecializeAUniqueKind_t14"; conjecture commented for convenience

% fof(th_sortalsSpecializeAUniqueKind_t14, conjecture, (
%   ![S]: ((sortal(S)) => (~?[U,U2]: (kind(U) & kind(U2) & specializes(S,U) & specializes(S,U2) & ~(U=U2))))
% )).

% If we have the taxonomy's axiomatization, then a25 becomes a theorem
% Ax |= "th_kindAndSubkindAreDisjoint_a25"; conjecture commented for convenience
  
% fof(th_kindAndSubkindAreDisjoint_a25, conjecture, (
%   ~?[T]: (kind(T) & subkind(T))
% )).
  
fof(ax_kindAndSubkindAreRigidSortals_a26, axiom, (
  ![T]: ((kind(T) | subkind(T)) <=> (rigid(T) & sortal(T)))
)).

% If we have the taxonomy's axiomatization, then a27 becomes a theorem
% Ax |= "th_phaseAndRoleAreDisjoint_a27"; conjecture commented for convenience
  
% fof(th_phaseAndRoleAreDisjoint_a27, conjecture, (
%   ~?[T]: (phase(T) & role(T))
% )).

fof(ax_phaseAndRoleAreAntiRigidSortals_a28, axiom, (
  ![T]: ((phase(T) | role(T)) <=> (antiRigid(T) & sortal(T)))
)).

% Skipping (a29) because we leave the concept of semi-rigid sortals out of this ontology.

fof(ax_categoriesAreRigidNonSortals_a30, axiom, (
  ![T]: ((category(T)) <=> (rigid(T) & nonSortal(T)))
)).

fof(ax_mixinsAreSemiRigidNonSortals_a30, axiom, (
  ![T]: ((mixin(T)) <=> (semiRigid(T) & nonSortal(T)))
)).

% If we have the taxonomy's axiomatization, then a31 becomes a theorem
% Ax |= "th_phaseMixinsAndRoleMixinsAreDisjoint_a31"; conjecture commented for convenience
  
% fof(th_phaseMixinAndRoleMixinAreDisjoint_a31, conjecture, (
%   ~?[T]: (phaseMixin(T) & roleMixin(T))
% )).

fof(ax_phaseMixinAndRoleMixinAreAntiRigidSortals_a28, axiom, (
  ![T]: ((phaseMixin(T) | roleMixin(T)) <=> (antiRigid(T) & nonSortal(T)))
)).

% Ax |= "th_leafCategoriesArePairwiseDisjoint_t18"; conjecture commented for convenience

% fof(th_leafCategoriesArePairwiseDisjoint_t18, conjecture, (
%   ~?[T]: (endurantType(T) & (
%     (
%       (kind(T) & subkind(T))
%       | (kind(T) & phase(T))
%       | (kind(T) & role(T))
%       | (kind(T) & category(T))
%       | (kind(T) & mixin(T))
%       | (kind(T) & phaseMixin(T))
%       | (kind(T) & roleMixin(T))
%     ) | (
%       (subkind(T) & phase(T))
%       | (subkind(T) & role(T))
%       | (subkind(T) & category(T))
%       | (subkind(T) & mixin(T))
%       | (subkind(T) & phaseMixin(T))
%       | (subkind(T) & roleMixin(T))
%     ) | (
%       (phase(T) & role(T))
%       | (phase(T) & category(T))
%       | (phase(T) & mixin(T))
%       | (phase(T) & phaseMixin(T))
%       | (phase(T) & roleMixin(T))
%     ) | (
%       (role(T) & category(T))
%       | (role(T) & mixin(T))
%       | (role(T) & phaseMixin(T))
%       | (role(T) & roleMixin(T))
%     ) | (
%       (category(T) & mixin(T))
%       | (category(T) & phaseMixin(T))
%       | (category(T) & roleMixin(T))
%     ) | (
%       (mixin(T) & phaseMixin(T))
%       | (mixin(T) & roleMixin(T))
%     ) | (
%       (phaseMixin(T) & roleMixin(T))
%     )
%   ))
% )).

% Ax |= "th_leafCategoriesCompletelyCategorizeAllEndurantTypes_t19"; conjecture commented for convenience
  
% fof(th_leafCategoriesCompletelyCategorizeAllEndurantTypes_t19, conjecture, (
%   ![T]: (endurantType(T) => (
%     kind(T) | subkind(T) | phase(T) | role(T) | category(T) | mixin(T) | phaseMixin(T) | roleMixin(T)
%   ))
% )).



% %%%%%%%%%%%%%%%%%%%%%%%% Definition of sortality

% % Every *individual* necessarily instantiates a kind  // imply kinds are rigid!

% fof(ax_individualKindMin_a10_revised_to_endurants, axiom, (
%     ![X] : (endurant(X) => ?[K]:(kind(K) & ![W]: (world(W)=>iof(X,K,W))))
%     )).

% % Every thing instantiates at most one kind (whenever it instantiates a kind it does not
% % possible instantiate a different one

% fof(ax_individualKindMax_a11, axiom, (
%     ![X,K,W] : ( ( kind(K) & iof(X,K,W)) =>
%                 (~?[Z,W2]: (~(Z=K) & kind(Z) & iof(X,Z,W2))) )
%     )).

% % Sortals definition, sortals are those types whose instances instantiate the same kind

% fof(ax_dsortal_a12, axiom, (
%     ![T] : (sortal(T) <=> (endurantType(T) &
%                     (?[K] : (kind(K) & ![X,W]: (world(W)=>(iof(X,T,W) => iof(X,K,W) ))))))
%     )).

% % A non-sortal is a type that is not a sortal

% fof(ax_dnonsortal_a13, axiom, (
%     ![T] : (nonSortal(T) <=> (endurantType(T) & ~sortal(T)) )
%     )).


% %%%%%%%%%%%%%%%%%%%%%%%% Definitions


% fof(ax_rigidSortal, axiom, (
%             ![T]: (rigidSortal(T)<=>(rigid(T)&sortal(T)))
%         )).

% fof(ax_rigidNonSortal, axiom, (
%     ![T]: (rigidNonSortal(T)<=>(rigid(T) & ~sortal(T)))
%                 )).
% fof(ax_antiRigidSortal, axiom, (
%                     ![T]: (antiRigidSortal(T)<=>(antiRigid(T)&sortal(T)))
%                                 )).

% fof(ax_antiRigidNonSortal, axiom, (
%             ![T]: (antiRigidNonSortal(T)<=>(antiRigid(T)&~sortal(T))))).

% fof(ax_semiRigidNonSortal, axiom, (
%                         ![T]: (semiRigidNonSortal(T)<=>(semiRigid(T)&~sortal(T))))).



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% %Taxonomy of endurant types according to the ontological nature of their instances

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % Endurant types are all those types whose instances are endurants

% fof(ax_dendurantType_a36, axiom, (
%       ![T]: (endurantType(T) <=> (type(T) & (![X,W]: (iof(X,T,W) => endurant(X)))))
%       )).

% % Substantial types are all those types whose instances are substantials

% fof(ax_dsubstantialType_a36, axiom, (
%           ![T]: (substantialType(T)<=> (type(T) & (![X,W]: (iof(X,T,W)=>substantial(X)))))
%       )).

% % Moment types are all those types whose instances are moments

% fof(ax_dmomentType_a36, axiom, (
%       ![T]: (momentType(T) <=> (type(T) & (![X,W]: (iof(X,T,W)=>moment(X)))))
%       )).

% % Relator types are all those types whose instances are relators

%   fof(ax_drelatorType_a36, axiom, (
%           ![T]: (relatorType(T)<=> (type(T) & (![X,W]: (iof(X,T,W)=>relator(X)))))
%       )).

% % Mode types are all those types whose instances are modes

%       fof(ax_dmodeType_a36, axiom, (
%           ![T]: (modeType(T)<=> (type(T) & (![X,W]: (iof(X,T,W)=>mode(X)))))
%       )).

% % Quality types are all those types whose instances are qualities

%       fof(ax_dqualityType_a36, axiom, (
%           ![T]: (qualityType(T) <=> (type(T) & (![X,W]: (iof(X,T,W)=>quality(X)))))
%       )).


% %%% Kinds are specialized according to the ontological nature of their instances

%       % Substantial kinds are those kinds whose instances are substantials
%       fof(ax_dsubstantialKind_a37, axiom, (
%           ![T]: (substantialKind(T)<=> (substantialType(T) & kind(T)))
%       )).

%       % Relator kinds are those kinds whose instances are relators
%       fof(ax_drelatorKind_a37, axiom, (
%           ![T]: (relatorKind(T) <=> (relatorType(T) & kind(T)))
%       )).

%       % Mode kinds are those kinds whose instances are modes
%       fof(ax_dmodeKind_a37, axiom, (
%           ![T]: (modeKind(T)<=> (modeType(T) & kind(T)))
%       )).

%       % Quality kinds are those kinds whose instances are relators
%       fof(ax_dqualityKind_a37, axiom, (
%           ![T]: (qualityKind(T)<=> (qualityType(T) & kind(T)))
%       )).

%       % every endurant is instance of one of the specific endurant kinds
%       fof(ax_everyEndurantInstantiatesSpecificKind_a38, axiom, (
%           ![X]: (endurant(X) => (?[W,K]: ((substantialkind(K)|relatorkind(K)|modekind(K)|qualitykind(K))& iof(X,K,W))))
%       )).




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% %Mereology

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% fof(ax_part_arguments, axiom, (![X,Y]: (part(X,Y) => (concreteIndividual(X) & concreteIndividual(Y))))).

% fof(ax_part_rifl, axiom, (![X]: (concreteIndividual(X) => part(X,X)))).

% fof(ax_part_antisymm, axiom, (![X,Y]: ((part(X,Y) & part(Y,X)) => (Y=X)))).

% fof(ax_part_tran, axiom, (![X,Y,Z]: ((part(X,Y) & part(Y,Z)) => part(X,Z)))).

% fof(ax_part_overlappin, axiom, (![X,Y]: (overlap(X,Y) <=> ?[Z]:(part(Z,X) & part(Z,Y))))).

% fof(ax_part_strong_supp, axiom, (![X,Y]: ((concreteIndividual(Y) & concreteIndividual(X) & ~part(Y,X)) => ?[Z]: (part(Z,Y) & ~overlap(Z,X))))).

% fof(ax_part_proper_part, axiom, (![X,Y]: (properPart(Y,X) <=> (part(Y,X) & ~part(X,Y))))).

% fof(ax_part_sum, axiom, (![Z,X,Y]: (sum(Z,X,Y) <=> ![W]:((overlap(W,Z) <=> (overlap(W,X) | overlap(W,X))))))).

% %Check how much fusion  and existence of sum is needed.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %
% %Composition
% %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% %Function as relations, "x function as y"

% fof(ax_function, axiom, (![X,Y]: (function(X,Y) => (endurant(X) & type(Y))))).

% %Generic functional independence

% fof(ax_gfd_a47, axiom, (![X1,Y1,W]: (gfd(X1,Y1,W) <=> (![X]: ((iof(X,X1,W) & function(X,X1))
%                                   => (?[Y]: (~(Y=X) & iof(Y,Y1,W) & function(Y,Y1)))))))).

% %Individual functional dependence

% fof(ax_ifd_a48, axiom, (![X,X1,Y,Y1,W]: (ifd(X,X1,Y,Y1,W) <=> (gfd(X1,Y1,W) & iof(X,X1,W) & iof(Y,Y1,W) &
%                                 (function(X,X1) => function(Y,Y1)))))).


% %Component of

% fof(ax_ifd_a49, axiom, (![X,X1,Y,Y1,W]: (componentOf(X,X1,Y,Y1,W) <=> (properPart(X,Y) & ifd(X,X1,Y,Y1,W))))).




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %
% %Constitution
% %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% %%%ConstitutedBy

% fof(ax_constituted_by_a58, axiom, (![X,Y,W]: (constitutedBy(X,Y,W) <=>
%       ((endurant(X) <=> endurant(Y)) & (perdurant(X) <=> perdurant(Y)) & world(W))))).

% fof(ax_constituted_by_a59, axiom, (![X,Y,X1,Y1,W]: ((constitutedBy(X,Y,W) & iof(X,X1,W) & iof(Y,Y1,W) & kind(X1) & kind(Y1)) => ~(X1=Y1)))).


% %%%%Generic constutional dependence (GCD).

% fof(ax_gcd_a60, axiom, (![X1,Y1]: ((gcd(X1,Y1) <=> (type(X1) & type(Y1) & ![X,W]:(iof(X,X1,W) =>
%                         (?[Y]:(iof(Y,Y1,W) & constitutedBy(X,Y,W))))))))).

% %%%%Constitution

% fof(ax_constitution_a61, axiom, (![X,Y,X1,Y1,W]: ((constitution(X,X1,Y,Y1,W)
%                   <=> (iof(X,X1,W) & iof(Y,Y1,W) & gcd(X1,Y1) & consitutedBy(X,Y,W)))))).


% fof(ax_constitution_perdurants_a62, axiom, (![X,Y,W]: ((perdurant(X) & constitutedBy(X,Y,W)) =>
%                     (![W1]: (exists(X,W1) => constitutedBy(X,Y,W1)))))).

% fof(ax_constitution_a63, axiom, (![X,Y,W]: (constitutedBy(X,Y,W) => ~(constitutedBy(Y,X,W))))).


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %
% %Existence, existential dependence, existential independence
% %
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% %Existence axiom.

% fof(ax_existence, axiom, (![X,W]: (ex(X,W) => (thing(X) & world(W))))).

% %existential dependence and independence

% fof(ax_existential_dependence, axiom, (![X,Y]: (ed(X,Y) <=> ![W]:(ex(X,W) => ex(Y,W))))).

% fof(ax_existential_independence, axiom, (![X,Y]: (ind(X,Y) <=> (~ed(X,Y) & ~ed(Y,X))))).




% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %Inherence
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%   fof(ax_inherence_type, axiom, (![X,Y]: (inheresIn(X,Y) => (moment(X) & (type(X) | concreteIndividual(Y)))))).

%         fof(ax_inherence_ed, axiom, (![X,Y]: (inheresIn(X,Y) => ed(X,Y)))).

%         fof(ax_inherence_irrifl, axiom, (![X]: ~inheresIn(X,X))).

%         fof(ax_inherence_asymm, axiom, (![X,Y]: (inheresIn(X,Y) => ~inheresIn(Y,X)))).

%         fof(ax_inherence_intrans, axiom, (![X,Y,Z]: ((inheresIn(X,Y) & inheresIn(Y,Z)) => ~inheresIn(X,Z)))).

%         fof(ax_inherence_unic, axiom, (![X,Y,Z]: ((inheresIn(X,Y) & inheresIn(X,Z)) => Y=Z))).


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %Moments
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% fof(ax_momentOf, axiom, (![M,X]: (momentOf(M,X) <=> (inheresIn(M,X) | (?[Y]:(ineheresIn(M,Y) & momentOf(Y,X))))))).

% fof(ax_ulitmate_bearer, axiom, (![B,M]: (ultimateBearerOf(B,M) <=> (~moment(B) & momentOf(M,B))))).

% fof(ax_ulitmate_bearer_existence, axiom, (![M]: (moment(M) => (?[B]: (ulimateBererOf(B,M)))))).

% fof(ax_ulitmate_bearer_unicity, axiom, (![M,B,B1]: ((ulimateBererOf(B,M) & ultimateBearerOf(B1,M)) => (B=B1)))).


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %Relators
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% %Externally dependent (we avoid introducing here the function "bearer of a moment", it is however unique)


% fof(ax_externally_dependent, axiom, (![X,Y]: (externallyDependent(X,Y) <=>
%                                         (ed(X,Y) & (![Z]: (inheresIn(X,Z) => ind(Y,Z))))))).

% %Externally dependent modes

% fof(ax_externally_dependent_mode, axiom, (![X]: (externallyDependentMode(X) <=> (mode(X) & (?[Y]: (externallyDependent(X,Y))))))).


% %Founded by

% fof(ax_founded_by, axiom, (![X,Y]: (foundedBy(X,Y) => ((externallyDependentMode(X) | relator(X)) & perdurant(Y))))).

% fof(ax_foundation_existence, axiom, (![X]: (externallyDependentMode(X) => (?[Y]: (foundedBy(X,Y)))))).

% fof(ax_foundation_unicity, axiom, (![X,Y,Z]: ((foundedBy(X,Y) & foundedBy(X,Z)) => (Y=Z)))).

% %Qua individual of

% fof(ax_qua_individual_of, axiom, (![X,Y]: (quaIndividualOf(X,Y) <=>
%                                       (![Z]:(overlap(Z,X) <=>
%                                             (externallyDependentMode(Z) & inheresIn(Z,Y) &
%                                             (![P]: (foundedBy(X,P) => foundedBy(Z,P))))))))).

% fof(ax_qua_individual_of_unicity, axiom, (![X,Y,Y1]: ((quaIndividualOf(X,Y) & quaIndividualOf(X,Y1)) => (Y=Y1)))).

% %Qua individual

% fof(ax_qua_individual_def, axiom, (![X]: ((quaIndividual(X) <=> (?[Y]: (quaIndividualOf(X,Y))))))).







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Instances

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Taxonomy of types 1.

%fof(ax_instance, axiom, perdurantType(pt1)).
%fof(ax_instance, axiom, axiom,objectType(ot1)).
%fof(ax_instance, axiom, collectiveType(ct1)).
%fof(ax_instance, axiom, quantityType(qnt1)).
%fof(ax_instance, axiom, relatorType(rt1)).
%fof(ax_instance, axiom, qualityType(qlt1)).
%fof(ax_instance, axiom, modeType(mot1)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Taxonomy of types 2

%fof(ax_instance, axiom,kind(k1)).
%fof(ax_instance, axiom, subKind(sk1)).
%fof(ax_instance, axiom, phase(phase1)).
%fof(ax_instance, axiom, role(role1)).
%fof(ax_instance, axiom, category(cat1)).
%fof(ax_instance, axiom, phaseMixin(pm1)).
%fof(ax_instance, axiom, roleMixin(rmi1)).
%fof(ax_instance, axiom, mixin(mix1)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Taxnomy of individuals


%fof(ax_instance, axiom, perdurant(p1)).
%fof(ax_instance, axiom, object(o1)).
%fof(ax_instance, axiom, collective(c1)).
%fof(ax_instance, axiom, quantity(quan1)).
%fof(ax_instance, axiom, relator(r1)).
%fof(ax_instance, axiom, quality(qual1)).
%fof(ax_instance, axiom, quaIndividual(qi1)).
%fof(ax_instance, axiom, disposition(d1)).
%fof(ax_instance, axiom, qualityDimension(qd1)).
%fof(ax_instance, axiom, qualitySpace(qs1)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
